## JVM相关整理
- 字节码文件结构
- JVM的内存区域
- JVM中对象创建过程
- JVM的垃圾回收机制
- JVM内存问题
### 字节码文件结构
Class文件是java虚拟机执行引擎的数据入口，Java虚拟机不和包括Java在内的任何语言绑定，只与 "Class文件" 这种特定的二进制文件所关联，Class文件中包含了Java虚拟机指令集合符号表以及若干其它辅助信息
- class文件结构
	- 魔数与Class文件版本
		- 头四个字节称为魔数:作用是确定这个文件是否为一个能被虚拟机接收的Class文件
		- 接着四个字节   第五和第六是次版本号，第七和第八是主版本号
	- 常量池
		- 字面量  :  接近常量概念，如文本字符串、声明为final的常量值等
		- 符号引用  :  属于编译原理方面的概念,包括 类和接口的全限定名  字段的名称和描述符  方法的名称和描述符
	- 访问标志
		- 两个字节,用于识别一些类或者接口层次的访问信息   如 : ACC_***(ACC_PUBLIC)
	- 类索引、父类索引与接口索引集合
		- 类索引用于确定这个类的全限定名
		- 父类索引用于确定这个类的父类的全限定名
		- 接口索引集合用来描述这个类实现了那些接口
	- 字段表集合 ： 用于描述接口或类中声明的变量
		- 类级变量
		- 实例变量
	- 方法表集合
		- 访问标志、名称索引、描述符索引、属性表集合
	- 属性表结合
- 字节码指令
虚拟机通过字节码指令操作class文件中的相关信息
### 内存区域划分
- 程序计数器
	- 用于当前线程所执行字节码文件的行号指示器,程序的跳转,判断选择等都依赖于此，线程私有
	- 唯一不会出现OutOfMemoryError的区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡
- 虚拟机栈-栈内存
	- 线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型
	- 主要存放了编译器可知的各种数据类型、对象引用（reference类型）
	- Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError
- 本地方法栈
	- 为虚拟机使用到的 Native 方法服务
	- 用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息
	- 也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常
- 堆内存
	- 存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
	- 在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）
- 方法区
	- 线程共享的内存区域
	- 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 运行时常量池
	- 单独的一块内存空间
	- 字节码文件中的字面量和符号引用
	- 直接使用双引号声明出来的 String 对象  String.intern() 方法出来的对象  会直接存储在常量池中
	- new 出来的对象会出现在堆内存中
	- 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。其余基本数据类型在数据范围内的值会出现在常量池
- 直接内存
### 对象创建过程
**创建时机：**
```Html
加载情况：a. 使用new关键字；b. 使用反射调用; c. 子类加载前; d. 执行前加载主类; f. Jdk1.7动态语言支持的时候的一些情况
特殊情况：
	1. 被动引用：
		1. 通过子类引用父类静态字段，不会导致子类初始化；
		2. 通过数组定义引用类，不会触发此类的初始化；
		3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量的类的初始化
	2. 当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用父接口中定义的常量）才会初始化
```
**创建过程：**
1. 检查：检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过，如果没有就进入类加载过程
2. 类加载：
	1. 加载 ： 通过类型的完全限定名，产生一个代表该类型的二进制数据流，解析数据结构并创建类对象
	2. 验证 ： 保证安全对字节流进行校验，包含文件格式验证，元数据验证，字节码验证以及符号引用验证
	3. 准备 ： 分配内存变量，设置初始值
		1. 
	4. 解析
	5. 初始化

	