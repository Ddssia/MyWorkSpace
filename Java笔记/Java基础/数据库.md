## 数据库整理
### MySql
##### 基本语法
1. DDL ：
```Java
增： 
	CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 编码表(GBK)
	CREATE TABLE 表名(列名1 数据类型1,列名2 数据类型2,...,列名n 数据类型n)
删： drop
改： alter
查： show / desc
```
2. DML / DQL : 
```Java
增：INSERT INTO 表名(列名1,列名2,...列名n) VALUES(数据1,数据2,..数据n)
删：DELETE FROM 表名 [WHERE 条件] / TRUNCATE TABLE 表名
改：UPDATE 表名 SET 列名1=值1,列名2=值2,...列名=值n [WHERE 条件]
查：SELECT [DISTINCT] 字段1 [AS 别名],字段2,...字段n [AS 别名] FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段 HAVING 分组之后的条件 ORDER BY 排序字段1[DESC\ASC],排序字段2[DESC\ASC]... LIMIT 分页限定
```
3. 约束 :
	1. 主键约束：primary key  自动增长 auto increment
	2. 唯一约束：unique
	3. 非空约束：not null
	4. 外键约束：foreign key
4. 基本函数：
	1. 字符操作：
		1. CONCAT(s1,s2...sn)  字符串拼接
		2. FIELD(s,s1,s2...)   返回第一个字符串 s 在字符串列表(s1,s2...)中的位置
		3. TRIM(s)             去掉字符串 s 开始和结尾处的空格
		4. UCASE(s)            将字符串转换为大写
	2. 数字函数：
		1. ABS(x) 绝对值
		2. AVG(expression) 平均值
		3. DIV  除
		4. FLOOR(x) 返回小于或等于 x 的最大整数
		5. MOD(x,y)  取余
	3. 日期函数：
		1. ADDTIME(t,n)  时间 t 加上 n 秒的时间
		2. CURDATE()  返回当前日期
		3. CURTIME()  返回当前时间
		4. DATE(“日期”) 从日期或日期时间表达式中提取日期值
		5. CAST(x AS type)  转换数据类型
	4. 高级函数：
		1. IF(expr,v1,v2)  如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。
		2. IFNULL(v1,v2)   如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。
		3. ISNULL(expression)  判断表达式是否为 NULL
##### 存储结构
- MyISAM
	- 概念 ： MyISAM在5.5版之前是MySQL的默认数据库引擎
	- 特点 ： 不支持	行锁(MyISAM只有表锁)\事务\外键\崩溃后的安全恢复，但支持 全文索引\延迟更新索引\压缩表
- InnoDB
	- 概念 ： 是MySQL的默认数据库引擎（5.5版之后）
	- 特点 ： 支持	行锁\事务\外键\崩溃后的安全恢复，但不支持 全文索引(5.6开始支持FULLTEXT 索引)
##### 索引
- 概念 ： 索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息
- 优缺点
	- 优点：
		- MySQL可以快速确定要在数据文件中间寻找的位置
		- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
		- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
	- 缺点
		- 索引的建立、维护需要存储空间和时间
		- 对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护
- 建立原则
	- 主键字段、经常查询的字段、经常连接的外键字段、经常作为判断条件的字段
	- 数据量小的，建立索引意义不大
	- 小型表或报表查询处理大多数或所有行的大型表的查询，索引不太重要
- 索引失效
	- 条件含有or会导致索引失效
	- like查询是以%开头，不会执行索引
	- 字符型字段为数字时在where条件里不添加引号
	- where语句中使用 <>、 != 、Not In 、not exist
	- where 字段名进行运算操作 = 值  会导致不会执行索引
- 数据结构
	- hash索引
		- 底层是hash表,需求为单条记录查询,哈希索引查询性能最快
	- B+Tree索引
		- 底层是B树中的B+Tree在两种存储结构中实现不同,但是大部分场景，建议选择BTree索引
##### 事务
- 隔离级别
	- READ_UNCOMMITTED（未提交读）              问题  可能会导致脏读、幻读或不可重复读
	- READ_COMMITTED（提交读）                  问题  幻读或不可重复读
	- REPEATABLE_READ（可重复读）==默认级别==        问题  幻读仍有可能发生
	- SERIALIZABLE（串行）                      问题  该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能
- 规则
	- A      Atomicity      原子性
	- C      Consistency    一致性
	- I      Isolation      隔离性
	- D  Durability     持久性
##### 锁
##### 分表
### 存储过程和存储函数

### 视图

### 数据库优化
根据官方文档，数据库优化可以在三个层面进行，在数据库级别进行优化，在硬件级别进行优化，平衡可移植性和性能，最主要了解的是在数据库级别优化
- 数据库级别进行优化
	- 表结构设计
	- 索引建立
	- 选择合适的存储引擎
	- 正确使用缓存
	- 选择合适的锁策略
	- 正确使用SQL语句