## 集合相关
### 体系结构描述
#### 单列集合
- Collection<E> 接口 特点:长度可变,元素可以重复,元素存储有序
	-  List<E> 特点:长度可变,元素可重复,存储有序,有索引
		- ArrayList<E> 
			1. 底层数组结构
			2. 长度可变,元素可重复,存储有序,有索引
			3. 查询快,增删慢
			4. 初始容量为10
			5. 扩容方法 grow() : 会按照
		- LinkedList<E>
			1. 底层是链表结构
			2. 长度可变,元素可重复,存储有序,无索引
			3. 查询慢,增删快
 		- Vector<E>
	 		1. 使用Syncoize修饰,线程安全,效率低
	-  Set<E> 特点:长度可变,元素不可重复,存储无序,无索引
		- HashSet<E>
			1. 底层是通过Hash表进行去重的单列集合
			2. 长度可变,元素不重复,存储无序,无索引
			3. 去重需要对象重写equals()和hashCode()
#### 双列集合
- Map<K,V> 接口 特点:a.键值对 b.键不可重复,且不为Null c.长度可变,存储无序
	- HashMap<K,V>
		1. JDK1.8 之前 HashMap 由 数组+链表 组成
		2. JDK1.8 以后在解决哈希冲突时，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间
		3. 默认初始容量为 16 默认负载因子为 0.75 当存储的元素超过 16*0.75 时,会执行 resize() 方法扩容,每次扩容大小为原来的2倍
	- LinkedHashMap<K,V>
		1. 继承了HashMap<K,V>,加入链表结构,存储有序
	- Hashtable<K,V>
		1. 单线程同步双列集合,效率低,线程安全
	- Properties<K,V>
		1. 属性集合,一般作为配置文件使用
### HashMap底层实现 
HashMap 通过 key 的 hashCode 经过==扰动函数==处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过==拉链法==解决冲突。
- 解释
	- 扰动函数 : 就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞
	- 拉链法 : 将链表和数组相结合,若遇到哈希冲突，则将冲突的值加到链表中即可 
	- 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的扰动 4 次 ,性能较JDK1.8差
	- loadFactor加载因子 : loadFactor加载因子是控制数组存放数据的疏密程度,loadFactor太大导致查找元素效率低，太小导致数组的利用率低
完整实现流程图
![image.png](0)
